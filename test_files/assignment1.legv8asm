// Notes:
// Saved: X19-X27                       Preserved
// Stack Pointer: X28 (SP)              Preserved
// Frame Pointer: X29 (FP)              Preserved
// Link (return address): X30 (LR)      Preserved
// Temporary: X9-X15                    Not Preserved
// Argument/Result: X0-X7               Not Preserved
/*-------------------------------------------------------------------------------------*/
main:
    // Setup the reversed array starting from the ASCII 0 -> ASCII A.
    // The array is stored in main memory, beginning at offset 0.
	MOVZ X0, #43, LSL #0
	BL reverse_array_builder

    // Sort the array ASC.
	MOVZ X1, #205, LSL #0
	BL selection_sort

    // Search for character 'X' (#88).
	MOVZ X1, #88, LSL #0
	MOVZ X2, #205, LSL #0
	BL iterative_binary_search

    // Store into arbitrary unused register, X27.
	MOVZ X27, #0, LSL #0
	ADD X27, X27, LR

    // Search for character 'X' (#88).
	MOVZ X0, #205, LSL #0
	MOVZ X1, #88, LSL #0
	BL setup_recursive_binary_search

    // Subtract output from X27.
	SUB X27, X27, LR

    // Store the outcome of the subtraction into main memory at offset 0
	STUR X27, [XZR, #0]

    // This should replace the start of our array, causing there to be
    // a 0 instead of an 'A' in main memory, decreasing '0' to B then 0.
	B end_main
/*-------------------------------------------------------------------------------------*/



/*-------------------------------------------------------------------------------------*/
// Implement a procedure to fill an array with consecutive
// 8-byte integers in reverse-sorted (high to low) order.
// Initial corresponding C code:
// void reverse_array_builder(int *arr, int length) // The array builder
// {
//     for (int i = 0; i < length; i++)
//     {
//         arr[i] = length - i;
//     }
// }
reverse_array_builder:
	SUBI SP, SP, #8         // Make space on the stack.
	STUR LR, [SP, #0]       // Store the link register.
	MOVZ X10, #0, LSL #0
	MOVZ X11, #0, LSL #0
	MOVZ X12, #0, LSL #0
	ADD X10, X10, X0
	ADDI X11, X11, #90

	array_builder_loop:
		STUR X11, [X12, #0]
		ADDI X12, X12, #8
		SUBI X10, X10, #1
		SUBI X11, X11, #1
		CBZ X10, array_builder_end
		B array_builder_loop

	array_builder_end:
        LDUR X10, [SP, #0]
        ADDI SP, SP, #8
        BR X10
/*-------------------------------------------------------------------------------------*/



/*-------------------------------------------------------------------------------------*/
// Implement a swap procedure that swaps the values
// in two different 8-byte integers in memory.
// Initial corresponding C code:
// void swap(int *x, int *y)
// {
//     int temp = *x;
//     *x = *y;
//     *y = temp;
// }
swap:
	SUBI SP, SP, #8		// Make space on the stack.
	STUR LR, [SP, #0]	// Store the link register.
	LDUR X10, [X1, #0]
	LDUR X11, [X2, #0]
	STUR X11, [X1, #0]
	STUR X10, [X2, #0]
	LDUR X10, [SP, #0]
	ADDI SP, SP, #8
	BR X10
/*-------------------------------------------------------------------------------------*/



/*-------------------------------------------------------------------------------------*/
// Implement a find smallest procedure that finds the smallest
// 8-byte integer in an array and returns its index.
// Initial corresponding C code:
// Returns the index in the smallest index of an array given a start and an end.
// int find_smallest_index(int arr[], int length)
// {
//     int smallest_index = 0;
//
//     for (int i = 0; i < length; i++)
//     {
//         if (arr[i] < arr[smallest_index])
//         {
//             smallest_index = i;
//         }
//     }
//     return smallest_index;
// }
find_smallest_index: // X0 : Pointer to address of the start of the array.
                     // X1 : Length of the array.
	SUBI SP, SP, #8         // Make space on the stack.
	STUR LR, [SP, #0]       // Store the link register.
	MOVZ X11, #0, LSL #0
	MOVZ X12, #0, LSL #0
	ADD X11, X11, X0
	ADDI X11, X11, #8
	ADD X12, X12, X0

	find_smallest_index_for_loop:
		SUBS X15, X11, X1
		B.GT find_smallest_index_end
		LDUR X13, [X11, #0] // arr[i]
		LDUR X14, [X12, #0]
		SUBS X15, X14, X13
		B.GT find_smallest_index_less_than
		B find_smallest_index_increment

		find_smallest_index_less_than:
			MOVZ X12, #0, LSL #0
			ADD X12, X12, X11

		find_smallest_index_increment:
			ADDI X11, X11, #8
			B find_smallest_index_for_loop

	find_smallest_index_end:
		LDUR X10, [SP, #0]
		ADDI SP, SP, #8
		MOVZ LR, #0, LSL #0
		ADD LR, LR, X12
		BR X10
/*-------------------------------------------------------------------------------------*/



/*-------------------------------------------------------------------------------------*/
// Implement selection sort using your find smallest and swap procedures. To
// be clear, selection sort can be more efficiently implemented without any
// helper procedures, but implementing it in assembly is easier with the
// helpers--and it gives you experience with procedure calls and stack
// manipulation--so we are requiring that you do it this way.
// Pseudocode for the selection sort:
// SelectionSort(array)
//    for each element in array in order from first to last:
//        swap element with smallest element in the subarray that it begins
// Initial corresponding C code:
// Sorts an array using selection sort.
// void selection_sort(int *arr, int length)
// {
//     for (int i = 0; i < length; i++)
//     {
//         int smallest_index = final_smallest_int(&arr[i], length - i);
//         swap(&arr[i], &arr[smallest_index + i]);
//     }
// }
selection_sort:
	SUBI SP, SP, #24        // Allocate space in the stack.
	STUR LR, [SP, #0]       // Stores the link register.
	STUR X1, [SP, #8]       // Stores the length of the array.
	STUR XZR, [SP, #16]     // Stores the index of swap.
	MOVZ X10, #0, LSL #0
	STUR X10, [SP, #16]     // Store into the stack.

	selection_sort_loop:
		LDUR X1, [SP, #8]
		SUBS X19, X10, X1
		B.GE selection_sort_end     // If this condition is met, jump to selection_sort_end.
		MOVZ X0, #0, LSL #0
		ADD X0, X0, X10
		LDUR X1, [SP, #8]           // Load in the length of the array.
		BL find_smallest_index		// Find the index of the smallest element.
		MOVZ X1, #0, LSL #0
		ADD X1, X1, LR
		LDUR X2, [SP, #16]          // Index to be swapped.
		BL swap                     // Perform the swap.
		LDUR X10, [SP, #16]
		ADDI X10, X10, #8
		STUR X10, [SP, #16]
		B selection_sort_loop       // Continue until B.GE condition is met.

	selection_sort_end:
		LDUR X10, [SP, #0]
		ADDI SP, SP, #24
		BR X10
/*-------------------------------------------------------------------------------------*/



/*-------------------------------------------------------------------------------------*/
// Implement an iterative binary search on an array of 8-byte integers
// Initial corresponding C code:
// Searches a sorted array for the index of a target, returns the index of the target.
// int iterative_binary_search(int *arr, int length, int target)
// {
//     int start = 0;
//     int end = length - 1;
//     int mid = (end + start) / 2;
//
//     while (arr[mid] != target)
//     {
//         if (start > end)
//         {
//             printf("ERROR iterative_binary_search: target is not in array\n");
//             return -1;
//         } else if (arr[mid] > target)
//         {
//             end = mid - 1;
//         } else
//         {
//             start = mid + 1;
//         }
//         mid = (end + start) / 2;
//     }
//     return mid;
// }
iterative_binary_search:
	SUBI SP, SP, #8         // Allocate space in the stack.
	STUR LR, [SP, #0]       // Stores the link register.
	MOVZ X10, #0, LSL #0 	// start
	MOVZ X11, #0, LSL #0 	// end
	MOVZ X12, #0, LSL #0 	// mid
	ADD X11, X11, X2
	MOVZ X13, #8, LSL #0
	UDIV X11, X11, X13

	iterative_binary_search_loop:
		SUBS X19, X10, X11	    // if (start > end)
		B.GT failure_end
		SUB X12, X11, X10
		MOVZ X13, #2, LSL #0
		UDIV X12, X12, X13
		ADD X12, X12, X10
		MOVZ X15, #0, LSL #0
		ADD X15, X15, X12
		LSL X15, X15, #3	    // Get 8-bit value by multiplying by 2^3
		LDUR X14, [X15, #0]	    // arr[mid]
		SUBS X19, X1, X14	    // else if (arr[mid] > target)
		B.EQ success_end
		B.LT right_modify
		B left_modify

	left_modify:
		MOVZ X10, #0, LSL #0
		ADDI X10, X12, #1
		B iterative_binary_search_loop 	        // Continue looping.

	right_modify:
		MOVZ X11, #0, LSL #0
		SUBI X11, X12, #1	//right = mid - 1
		B iterative_binary_search_loop	        // Continue looping.

	success_end:
		MOVZ LR, #0, LSL #0
		ADD LR, LR, X12
		LDUR X13, [SP, #0]
		ADDI SP, SP, #8
		BR X13

	failure_end:
		MOVZ LR, #256, LSL #0	                // Add arbitrary value to indicate failure.
		LDUR X13, [SP, #0]
		ADDI SP, SP, #8
		BR X13
/*-------------------------------------------------------------------------------------*/



/*-------------------------------------------------------------------------------------*/
// Implement a recursive binary search on an array of 8-byte integers
// Initial corresponding C code:
// Searches for target in an array arr and returns the index of it.
// int recursive_binary_search(int *arr, int start, int end, int target)
// {
//     if (start > end)
//     {
//         printf("Failure: Target is not in the array.\n");
//         return -1;
//     }
//
//     int mid = (end + start) / 2;
//
//     if (arr[mid] == target)
//     {
//         return mid;
//     } else if (arr[mid] > target)
//     {
//         return recursive_binary_search(arr, start, mid - 1, target);
//     } else
//     {
//         return recursive_binary_search(arr, mid + 1, end, target);
//     }
// }
recursive_binary_search:
	SUBI SP, SP, #8         // Allocate space in the stack.
	STUR LR, [SP, #0]       // Stores the link register.
	MOVZ X10, #0, LSL #0 	// start
	MOVZ X11, #0, LSL #0 	// end
	MOVZ X12, #0, LSL #0 	// mid
	ADD X10, X10, X0
	ADD X11, X11, X1
	SUBS X19, X10, X11	    // if (start > end)
	B.GT failure_end

    // int mid = (end + start) / 2;
	SUB X12, X11, X10
	MOVZ X13, #2, LSL #0
	UDIV X12, X12, X13
	ADD X12, X12, X10

	MOVZ X15, #0, LSL #0
	ADD X15, X15, X12
	LSL X15, X15, #3	    // Get 8-bit value by multiplying by 2^3
	LDUR X14, [X15, #0]	    // arr[mid]

	SUBS X19, X2, X14
	B.EQ success_end
	B.LT modify_right
	B modify_left

	modify_left:
		MOVZ X0, #0, LSL #0
		ADD X0, X0, X12
		ADDI X0, X0, #1
		BL recursive_binary_search
		B success_end

	modify_right:
		MOVZ X1, #0, LSL #0
		ADD X1, X1, X12
		SUBI X1, X1, #1
		BL recursive_binary_search
		B success_end

	success_end:
		MOVZ LR, #0, LSL #0
		ADD LR, LR, X12
		LDUR X13, [SP, #0]
		ADDI SP, SP, #8
		BR X13

	failure_end:
		MOVZ LR, #256, LSL #0	// Add arbitrary value to indicate failure.
		LDUR X13, [SP, #0]
		ADDI SP, SP, #8
		BR X13
/*-------------------------------------------------------------------------------------*/



/*-------------------------------------------------------------------------------------*/
setup_recursive_binary_search:
	SUBI SP, SP, #8         // Allocate space in the stack.
	STUR LR, [SP, #0]       // Stores the link register.
	MOVZ X2, #0, LSL #0
	ADD X2, X2, X1
	MOVZ X1, #0, LSL #0
	ADD X1, X1, X0
	MOVZ X13, #8, LSL #0
	UDIV X1, X1, X13
	MOVZ X0, #0, LSL #0 //set X0
	BL recursive_binary_search
	LDUR X13, [SP, #0]
	ADDI SP, SP, #8
	BR X13
/*-------------------------------------------------------------------------------------*/



/*-------------------------------------------------------------------------------------*/
end_main:
    DUMP
/*-------------------------------------------------------------------------------------*/
